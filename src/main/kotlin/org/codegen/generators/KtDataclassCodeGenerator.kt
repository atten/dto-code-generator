package org.codegen.generators

import org.codegen.dto.*
import org.codegen.extensions.*

val KOTLIN_KEYWORDS = setOf("open", "fun")  // incomplete and contains only known

open class KtDataclassCodeGenerator: AbstractCodeGenerator() {
    private val headers = mutableListOf<String>()
    private val enumClasses = mutableListOf<String>()

    protected fun addHeader(str: String) {
        if (!headers.contains(str))
            headers.add(str)
    }

    private fun addEnumClass(str: String) {
        if (!enumClasses.contains(str))
            enumClasses.add(str)
    }

    fun getHeaders() = headers
    fun getEnumClasses() = enumClasses

    protected open fun buildFieldDefinition(field: Field): String {
        val dataType = getDtype(field.dtype)
        val definitionKeyword = "val"
        val fieldName = field.name.normalize().camelCase()
        val assignmentExpression = if (field.default == UNSET) {
            ""
        } else {
            dataType.toGeneratedValue(field.default ?: "null")
        }
            .let { if (field.multiple) "listOf($it)" else it}
            .let { if (it.isEmpty()) "" else "= $it" }

        val typeName = dataType.definition
            .let { if (field.isEnum) (field.enumPrefix ?: field.name).camelCase().capitalize() else it }
            .let { if (field.nullable) "$it?" else it }
            .let { if (field.multiple) "List<$it>" else it }
        return "$definitionKeyword $fieldName: $typeName $assignmentExpression".trim()
    }

    open fun buildEntity(entity: Entity, annotations: List<String> = listOf()): String {
        val preLines = mutableListOf<String>()
        val className = entity.name.camelCase().capitalize()
        val definition = "data class $className("
        val lines = annotations.toMutableList().also { it.add(definition) }

        entity.description?.also {
            preLines.add("/**")
            preLines.add(" * " + entity.description)
            preLines.add("*/")
        }

        // include parent class fields (because data class inheritance is not allowed)
        val includedFields = entity.parent?.let { getIncludedEntity(it).fields } ?: listOf()

        for (field in entity.fields + includedFields) {
            val fullDefinition = buildFieldDefinition(field)

            field.enum?.let { enum ->
                val enumName = (field.enumPrefix ?: field.name).camelCase().capitalize()
                val enumBody = enum.map { row -> "    ${row.key.camelCase().let { if (it in KOTLIN_KEYWORDS) "`$it`" else it }}(\"${row.key}\")," }.joinToString(
                    separator = "\n",
                    prefix = "enum class $enumName(val value: String) {\n",
                    postfix = "\n}\n"
                )
                addEnumClass(enumBody)
            }

            field.shortDescription?.let { lines.add("    // $it") }
            field.longDescription?.let { lines.add("    // $it") }
            lines.add("    ${fullDefinition.replace("\n", "\n    ")},")

            // include headers
            getDtype(field.dtype).requiredHeaders.forEach { addHeader(it.substituteEnvVars()) }
        }

        lines.add(")")
        return (preLines + lines).joinToString("\n", postfix = "\n")
    }

    override fun build(): String {
        val builtEntities = getEntities(includeMethods = true).map { buildEntity(it) }
        val topHeader = "// Generated by DTO-Codegen\npackage \${PACKAGE_NAME}\n\n".substituteEnvVars()
        return headers.sorted().joinToString("\n", prefix = topHeader, postfix = "\n\n") +
                enumClasses.joinToString(separator = "\n", postfix = "\n") +
                builtEntities.joinToString("\n")
    }
}